A=xlsread('Tabl.xlsx'); % Здесь я импортррую данные из таблицы EXCEL в рабочее пространство MATLAB
B=[]; % Вектор строка, в которую я буду записывать значения из матрицы A

% Ниже фрагмент кода, в котором я заполняю вектор B значениями из матрицы A
stolb=length(A);
strok=length(A(:,1));
for i=1:strok
    for j=1:stolb
        if ~isnan(A(i,j)) % Проверяю не принимает ли элемент матрицы A значение NaN
            B = [B A(i,j)];
        end
    end
end

B=sort(B); % Сортирую список B по возрастанию элементов в нем
Val_Kolvo=[B(1);0]; % Создаю матрицу 2x1. В первой строке значение элемента, а во второй количество ее повторений
k=2; % индекс матрицы Val_Kolvo
for i=2:length(B)
    if B(i-1)~=B(i)
        Val_Kolvo(1,k)=[B(i)]; % Если текущий элемент не равен предыдущему я запоминаю этот элемент в Val_kolvo
        k=k+1; % Увеличиваю индекс, для того чтобы следуещее неповторяющееся значение сохранить под след. индексом
    end
end

% Ниже фрагмент кода, в котором я посчитываю кол-во повторений элемента из
% Val_kolvo в списке B, а затем запомниаю во второй строке Val_kolvo кол-во
% повторений
for i=1:length(Val_Kolvo)
    count=0;
    for j=1:length(B)
        if Val_Kolvo(1,i)==B(j)
            count=count+1;
        end
    end
    Val_Kolvo(2,i)=count;
end
Val_Kolvo
% Таким образом мы получили статистический ряд Val_kolvo, в котром первая
% строка это значение, а втроая строка кол-во повторений этого значения

% Ниже фрагмент кода, в котором расчитывется оптимальный шаг для интервалов
r=(Val_Kolvo(1,length(Val_Kolvo)))-(Val_Kolvo(1,1));
k=round(1+3.322*log10(length(B)));
delta=r/k;

% Далее создаем матрицу 2xk, в котором в первой строке будет хранится
% интервал (правая граница этого интервала), а во втрой строке кол-во
% значений попавших в этот интервал
Interv=zeros(2,k);
Gr=Interv; % Gr - вспомогательная матрица для построения гистограммы
Interv(1,:)=Val_Kolvo(1,1)+delta:delta:Val_Kolvo(1,length(Val_Kolvo));

% Ниже указан фргамент кода, в котором я считаю кол-во вхождений значений в
% определенный интервал
i=1;
j=1;
s=0;
while i<=length(Val_Kolvo)
    if Val_Kolvo(1,i)<=Interv(1,j)
        s=s+Val_Kolvo(2,i);
        Interv(2,j)=s;
        i=i+1;
    else
        s=0;
        j=j+1;
    end
end
Interv
% Таким образом я получил интервальный ряд Interval

% Теперь найдем значения точечных оценок мат. ожидания и дисперсии
x=sum(B)/length(B); % Выборочное среднее
s=0;
for i=1:length(B)
    s=s+(B(i)-x)^2;
end
s=s/(length(B)-1); % Исправленная выборочная дисперсия
x
s

% Теперь я посторю гистограмму
Gr=Interv(1,1)-delta/2:delta:Interv(1,length(Interv))-delta/2;
close all
figure
bar(Gr, Interv(2,:)/delta/length(B), 1) % h=Interv(2,:)/delta/length(B)
title('Гистограмма')
grid on
grid minor


